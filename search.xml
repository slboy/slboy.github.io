<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue页面监听iframe事件]]></title>
    <url>%2F2019%2F10%2F18%2Fvue%E9%A1%B5%E9%9D%A2%E7%9B%91%E5%90%ACiframe%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[问题 vue页面与iframe页面之间的通信问题，监听iframe嵌套页面的按钮单机事件 解決 1.使用ref获取iframe内部对象的全部属性 2.vue页面通过addEventListener 监听信号，iframe通过postMessage进行信号传递； 3.注意EventListener事件的销毁 代码1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;iframe ref=&quot;iframe&quot; src=&quot;xxxx&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;800&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; iframeWin: &#123;&#125; &#125; &#125;, mounted () &#123; this.iframeWin = this.$refs.iframe.contentWindow this.$nextTick(() =&gt; &#123; window.addEventListener(&apos;message&apos;, this.handleMessage) &#125;) &#125;, destroyed () &#123; // 注意移除监听！注意移除监听！注意移除监听！ window.removeEventListener(&apos;message&apos;, this.handleMessage) &#125; methods: &#123; handleMessage (event) &#123; // 根据上面制定的结构来解析 iframe 内部发回来的数据 const data = event.data switch (data.cmd) &#123; case &apos;case1&apos;: // 业务逻辑 break &#125; &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314&lt;body&gt; &lt;div class=&quot;div&quot;&gt; &lt;h1&gt;这是一个嵌套页面&lt;/h1&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var domain = &apos;*&apos;; // 消息源 document.getElementById(&apos;btn&apos;).addEventListener(&apos;click&apos;, function () &#123; window.parent.postMessage(&#123; cmd: &apos;case1&apos; // &#125;, domain) &#125;) &lt;/script&gt;&lt;/body&gt; 参考： vue与iframe通信]]></content>
      <tags>
        <tag>vue</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的keep-alive问题]]></title>
    <url>%2F2019%2F07%2F12%2Fvue%E7%9A%84keep-alive%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题：关闭标签页再次打开仍有缓存项目遇到了一个关于keep-alive的缓存问题(vue)，如下图标签页采用keep-alive缓存包裹，预期实现关闭标签页再次打开页面为初始化状态 解决：采用vuex123&lt;keep-alive :include="tags"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。见kepp-alive文档 store.js123456789101112131415161718import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; tagList: [], &#125;, getters: &#123; &#125;, mutations: &#123; setTag (state, arr) &#123; state.tagList = arr &#125; &#125;&#125;) home 组件12345678910111213141516171819202122232425262728293031323334353637methods: &#123; setTags (route) &#123; //tagList方法 let arr = this.tagsList if (route.path === '/homePage') return false; const isExist = arr.some(item =&gt; &#123; return item.path === route.fullPath; &#125;); if(!isExist)&#123; //如果不存在则添加 this.tagsList.push(&#123; title: route.meta.title, path: route.fullPath, name: route.matched[1].components.default.name &#125;) &#125; this.$store.commit('setTag', [...arr]) //调用store方法 &#125;&#125;,computed: &#123; tags () &#123; //对tagList进行处理 let arr = [] this.tagsList.map((item) =&gt; &#123; arr.push(item.name) &#125;) return arr &#125;, tagsList () &#123; //获取store的tagList return this.$store.state.tagList &#125;&#125;,created()&#123; this.setTags(this.$route)&#125;,watch: &#123; $route(newValue, oldValue)&#123; //监听路由的变化 this.setTags(newValue); &#125;&#125; 在tags组件对标签删除添加单机事件，对tagList进行操作 1234567891011closeTags(index) &#123; let arr = [...this.tagsList] const delItem = arr.splice(index, 1)[0]; if (arr.length &gt; 0) &#123; let item = arr[index] ? arr[index] : arr[index-1]; delItem.path === this.$route.fullPath &amp;&amp; this.$router.push(item.path); &#125; else &#123; // 如果最后一个则跳到首页 this.$router.push('/homePage'); &#125; this.$store.commit('setTag', arr)&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html2canvas绘图空白问题]]></title>
    <url>%2F2019%2F07%2F09%2Fhtml2canvas%2F</url>
    <content type="text"><![CDATA[公司让修改一个08年的台湾项目，加上一个截屏保存图片功能，使用了html2canvas,发现保存之后一片空白，最后发现是由于滚动条的原因，附上代码 12345678910html2canvas(document.getElementById("box"),&#123; logging: false, //日志输出 useCORS: true, //图片允许跨域 width: '', // 默认element宽 height: '', // 默认element高 x: 0, // 裁剪画布x坐标 y: document.getElementById("box").offsetTop //裁剪画布y坐标，之前用的window.pageYOffset不行&#125;).then(function(canvas) &#123; // xxxxxx&#125;) 更多配置请查阅文档html2canvas]]></content>
      <tags>
        <tag>插件</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
